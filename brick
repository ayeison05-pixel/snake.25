<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <title>Brick Breaker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 8px;
      overflow: hidden;
      touch-action: none;
      width: 100%;
      max-width: 100vw;
    }
    h1 {
      font-size: 1.6em;
      margin: 6px 0 4px;
      text-align: center;
      text-shadow: 0 0 6px #0f0;
    }
    #score, #high-score, #lives {
      font-size: 1.1em;
      margin: 3px 0;
    }
    canvas {
      border: 2px solid #0a0;
      background: #000;
      display: block;
      margin: 6px auto;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
      max-width: 95vw;
      max-height: 70vh;
      width: auto;
      height: auto;
    }
    #game-over, #level-complete {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      color: #f00;
      font-size: 1.6em;
      text-shadow: 0 0 10px #f00;
      z-index: 10;
    }
    #level-complete {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    #restart-btn {
      margin-top: 20px;
      padding: 8px 20px;
      background: #111;
      color: #0f0;
      border: 1px solid #0a0;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 1.2em;
      cursor: pointer;
    }
    #restart-btn:active {
      background: #030;
    }
  </style>
</head>
<body>
  <h1>Brick Breaker</h1>
  <div id="score">Puntuación: 0</div>
  <div id="high-score">Mejor puntuación: 0</div>
  <div id="lives">Vidas: 3</div>
  <canvas id="game"></canvas>

  <div id="game-over">
    ¡JUEGO TERMINADO!
    <button id="restart-btn">JUGAR DE NUEVO</button>
  </div>

  <div id="level-complete">
    ¡NIVEL COMPLETADO!
    <button id="restart-btn-complete">JUGAR DE NUEVO</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('high-score');
    const livesDisplay = document.getElementById('lives');
    const gameOverScreen = document.getElementById('game-over');
    const levelCompleteScreen = document.getElementById('level-complete');
    const restartBtn = document.getElementById('restart-btn');
    const restartBtnComplete = document.getElementById('restart-btn-complete');

    // Configuración
    let canvasWidth, canvasHeight;
    let paddle = { x: 0, y: 0, width: 80, height: 12, speed: 8 };
    let ball = { x: 0, y: 0, radius: 6, dx: 4, dy: -4 };
    let bricks = [];
    const brickRows = 5;
    const brickCols = 8;
    const brickWidth = 60;
    const brickHeight = 20;
    const brickPadding = 4;
    const brickOffsetTop = 40;
    const brickOffsetLeft = 30;

    let score = 0;
    let highScore = localStorage.getItem('brickHighScore') || 0;
    let lives = 3;
    let gameRunning = false;
    let animationId = null;

    // Colores por fila (de abajo a arriba)
    const brickColors = ['#0f0', '#0ff', '#ff0', '#f0f', '#f00'];

    function initGame() {
      // Ajustar canvas
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = window.innerHeight * 0.7;
      canvas.width = maxWidth;
      canvas.height = maxHeight;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;

      // Posicionar paleta
      paddle.x = (canvasWidth - paddle.width) / 2;
      paddle.y = canvasHeight - 30;

      // Posicionar pelota
      ball.x = canvasWidth / 2;
      ball.y = paddle.y - ball.radius - 5;

      // Crear ladrillos
      bricks = [];
      for (let r = 0; r < brickRows; r++) {
        bricks[r] = [];
        for (let c = 0; c < brickCols; c++) {
          const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          // Ajustar si se sale del canvas
          if (brickX + brickWidth < canvasWidth - 20) {
            bricks[r][c] = { x: brickX, y: brickY, status: 1 };
          } else {
            bricks[r][c] = null;
          }
        }
      }

      score = 0;
      lives = 3;
      gameRunning = true;
      scoreDisplay.textContent = `Puntuación: ${score}`;
      livesDisplay.textContent = `Vidas: ${lives}`;
      highScoreDisplay.textContent = `Mejor puntuación: ${highScore}`;
      gameOverScreen.style.display = 'none';
      levelCompleteScreen.style.display = 'none';

      if (animationId) cancelAnimationFrame(animationId);
      gameLoop();
    }

    function drawPaddle() {
      ctx.fillStyle = '#fff';
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            ctx.fillStyle = brickColors[r % brickColors.length];
            ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(brick.x, brick.y, brickWidth, brickHeight);
          }
        }
      }
    }

    function collisionDetection() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            if (
              ball.x + ball.radius > brick.x &&
              ball.x - ball.radius < brick.x + brickWidth &&
              ball.y + ball.radius > brick.y &&
              ball.y - ball.radius < brick.y + brickHeight
            ) {
              ball.dy = -ball.dy;
              brick.status = 0;
              score += 10 * (r + 1); // Más puntos por filas superiores
              scoreDisplay.textContent = `Puntuación: ${score}`;

              // Verificar si ganó
              let bricksLeft = false;
              for (let rr = 0; rr < brickRows; rr++) {
                for (let cc = 0; cc < brickCols; cc++) {
                  if (bricks[rr][cc] && bricks[rr][cc].status === 1) {
                    bricksLeft = true;
                    break;
                  }
                }
                if (bricksLeft) break;
              }
              if (!bricksLeft) {
                levelComplete();
              }
            }
          }
        }
      }
    }

    function levelComplete() {
      gameRunning = false;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('brickHighScore', highScore);
        highScoreDisplay.textContent = `Mejor puntuación: ${highScore}`;
      }
      levelCompleteScreen.style.display = 'flex';
    }

    function gameOver() {
      gameRunning = false;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('brickHighScore', highScore);
        highScoreDisplay.textContent = `Mejor puntuación: ${highScore}`;
      }
      gameOverScreen.style.display = 'flex';
    }

    function update() {
      if (!gameRunning) return;

      // Movimiento de la pelota
      ball.x += ball.dx;
      ball.y += ball.dy;

      // Rebote en paredes laterales
      if (ball.x + ball.radius > canvasWidth || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
      }

      // Rebote en techo
      if (ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
      }

      // Rebote en paleta
      if (
        ball.y + ball.radius > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.width
      ) {
        // Ángulo depende de dónde golpea la paleta
        const hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
        const angle = hitPoint * (Math.PI / 3); // -60° a +60°
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
        ball.dx = speed * Math.sin(angle);
        ball.dy = -speed * Math.cos(angle);
      }

      // Pelota cae
      if (ball.y + ball.radius > canvasHeight) {
        lives--;
        livesDisplay.textContent = `Vidas: ${lives}`;
        if (lives <= 0) {
          gameOver();
        } else {
          // Reiniciar pelota
          ball.x = canvasWidth / 2;
          ball.y = paddle.y - ball.radius - 5;
          ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
          ball.dy = -4;
        }
      }

      collisionDetection();
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      drawBricks();
      drawPaddle();
      drawBall();
    }

    function gameLoop() {
      update();
      draw();
      if (gameRunning) {
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    // Controles táctiles: arrastrar paleta
    let isDragging = false;

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      e.preventDefault();
    });

    canvas.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
      paddle.x = touchX - paddle.width / 2;
      // Limitar dentro del canvas
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvasWidth) paddle.x = canvasWidth - paddle.width;
    });

    canvas.addEventListener('touchend', () => {
      isDragging = false;
    });

    // También soportar mouse (para pruebas en escritorio)
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      paddle.x = mouseX - paddle.width / 2;
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvasWidth) paddle.x = canvasWidth - paddle.width;
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Botones
    restartBtn.addEventListener('click', initGame);
    restartBtnComplete.addEventListener('click', initGame);

    // Iniciar
    window.addEventListener('load', initGame);
    window.addEventListener('resize', () => {
      if (gameRunning) initGame(); // Reiniciar suavemente al cambiar tamaño
    });
  </script>
</body>
</html>
