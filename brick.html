<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <meta name="google" content="notranslate">
  <meta name="robots" content="noindex, nofollow">
  <title>Brick Breaker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 8px;
      overflow: hidden;
      touch-action: none;
      width: 100%;
      max-width: 100vw;
    }
    .no-select {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    h1 {
      font-size: 1.6em;
      margin: 6px 0 4px;
      text-align: center;
      text-shadow: 0 0 6px #0f0;
    }
    #score {
      font-size: 1.1em;
      margin: 3px 0;
    }
    #lives {
      font-size: 1.4em;
      margin: 3px 0;
      color: #f00;
    }
    canvas {
      border: 2px solid #0a0;
      background: #000;
      display: block;
      margin: 6px auto;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
      max-width: 95vw;
      max-height: 70vh;
      width: auto;
      height: auto;
    }
    /* Botones flotantes */
    #home-btn, #pause-btn {
      position: absolute;
      top: 10px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid #0a0;
      background: rgba(20, 20, 20, 0.7);
      color: #0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      z-index: 5;
      cursor: pointer;
    }
    #home-btn { right: 10px; }
    #pause-btn { right: 52px; }
    #home-btn:active, #pause-btn:active {
      background: rgba(0, 255, 0, 0.2);
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #0f0;
      font-size: 1.6em;
      z-index: 10;
    }
    #overlay h2 {
      margin-bottom: 20px;
      text-shadow: 0 0 8px #0f0;
    }
    #overlay button {
      margin: 8px;
      padding: 8px 20px;
      background: #111;
      color: #0f0;
      border: 1px solid #0a0;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 1.2em;
      cursor: pointer;
    }
    #overlay button:active {
      background: #030;
    }
  </style>
</head>
<body>
  <h1 class="no-select">Brick Breaker</h1>
  <div id="score" class="no-select">Puntos: 0</div>
  <div id="lives" class="no-select">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  <canvas id="game"></canvas>

  <button id="home-btn" class="no-select">üè†</button>
  <button id="pause-btn" class="no-select">‚èØ</button>

  <div id="overlay">
    <h2 id="overlay-title">PAUSA</h2>
    <button id="resume-btn">CONTINUAR</button>
    <button id="menu-btn">VOLVER AL INICIO</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const homeBtn = document.getElementById('home-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const menuBtn = document.getElementById('menu-btn');

    // Configuraci√≥n
    let canvasWidth, canvasHeight;
    let paddle = { x: 0, y: 0, width: 90, height: 14 };
    let ball = { x: 0, y: 0, radius: 6, dx: 4, dy: -4 };
    let bricks = [];
    const brickRows = 10;
    const brickCols = 12;
    const brickWidth = 50;
    const brickHeight = 16;
    const brickPadding = 3;
    const brickOffsetTop = 40;
    const brickOffsetLeft = 20;

    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let gamePaused = false;
    let ballLaunched = false;
    let animationId = null;

    // Colores para 10 filas (de abajo a arriba)
    const brickColors = [
      '#0f0', '#0ff', '#ff0', '#f0f', '#f00',
      '#fa0', '#0af', '#f5f', '#afa', '#a0f'
    ];

    // === SONIDOS GENERADOS ===
    function playSound(frequency, duration, type = 'sine') {
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        gainNode.gain.value = 0.1;
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration);
      } catch (e) {
        // Silencio si no se puede reproducir
      }
    }

    function initGame() {
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = window.innerHeight * 0.7;
      canvas.width = maxWidth;
      canvas.height = maxHeight;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;

      paddle.x = (canvasWidth - paddle.width) / 2;
      paddle.y = canvasHeight - 30;
      ball.x = canvasWidth / 2;
      ball.y = paddle.y - ball.radius - 5;
      ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
      ball.dy = -4;

      bricks = [];
      for (let r = 0; r < brickRows; r++) {
        bricks[r] = [];
        for (let c = 0; c < brickCols; c++) {
          const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
          if (brickX + brickWidth < canvasWidth - 10) {
            bricks[r][c] = { x: brickX, y: brickY, status: 1 };
          } else {
            bricks[r][c] = null;
          }
        }
      }

      score = 0;
      lives = 3;
      gameRunning = true;
      gamePaused = false;
      ballLaunched = false;
      updateLivesDisplay();
      scoreDisplay.textContent = `Puntos: ${score}`;
      overlay.style.display = 'none';
      if (animationId) cancelAnimationFrame(animationId);
      gameLoop();
    }

    function updateLivesDisplay() {
      livesDisplay.textContent = '‚ù§Ô∏è'.repeat(lives);
    }

    function drawPaddle() {
      ctx.fillStyle = 'rgba(255, 165, 0, 0.8)'; // Naranja opaco
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            ctx.fillStyle = brickColors[r % brickColors.length];
            ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(brick.x, brick.y, brickWidth, brickHeight);
          }
        }
      }
    }

    function collisionDetection() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            if (
              ball.x + ball.radius > brick.x &&
              ball.x - ball.radius < brick.x + brickWidth &&
              ball.y + ball.radius > brick.y &&
              ball.y - ball.radius < brick.y + brickHeight
            ) {
              ball.dy = -ball.dy;
              brick.status = 0;
              score += 10;
              scoreDisplay.textContent = `Puntos: ${score}`;
              playSound(300, 0.1); // Sonido de rebote

              let bricksLeft = false;
              for (let rr = 0; rr < brickRows; rr++) {
                for (let cc = 0; cc < brickCols; cc++) {
                  if (bricks[rr][cc] && bricks[rr][cc].status === 1) {
                    bricksLeft = true;
                    break;
                  }
                }
                if (bricksLeft) break;
              }
              if (!bricksLeft) {
                playSound(500, 0.3, 'sine');
                setTimeout(() => showOverlay('¬°NIVEL COMPLETADO!', true), 300);
              }
              return;
            }
          }
        }
      }
    }

    function showOverlay(title, isWin = false) {
      gameRunning = false;
      gamePaused = true;
      overlayTitle.textContent = title;
      overlay.style.display = 'flex';
    }

    function launchBall() {
      if (!ballLaunched && gameRunning && !gamePaused) {
        ballLaunched = true;
      }
    }

    function update() {
      if (!gameRunning || gamePaused) return;

      if (ballLaunched) {
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Paredes laterales
        if (ball.x + ball.radius > canvasWidth || ball.x - ball.radius < 0) {
          ball.dx = -ball.dx;
          playSound(200, 0.05);
        }

        // Techo
        if (ball.y - ball.radius < 0) {
          ball.dy = -ball.dy;
          playSound(200, 0.05);
        }

        // Paleta
        if (
          ball.y + ball.radius > paddle.y &&
          ball.x > paddle.x &&
          ball.x < paddle.x + paddle.width &&
          ball.dy > 0
        ) {
          const hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          const angle = hitPoint * (Math.PI / 3);
          const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
          ball.dx = speed * Math.sin(angle);
          ball.dy = -speed * Math.cos(angle);
          playSound(250, 0.08);
        }

        // Pelota cae
        if (ball.y + ball.radius > canvasHeight) {
          lives--;
          updateLivesDisplay();
          playSound(100, 0.2, 'square');
          if (lives <= 0) {
            showOverlay('¬°JUEGO TERMINADO!');
          } else {
            // Detener la pelota y esperar nuevo lanzamiento
            ballLaunched = false;
            ball.x = canvasWidth / 2;
            ball.y = paddle.y - ball.radius - 5;
            ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -4;
          }
        }

        collisionDetection();
      } else {
        // La pelota sigue a la paleta antes del lanzamiento
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddle.y - ball.radius - 5;
      }
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      drawBricks();
      drawPaddle();
      drawBall();
    }

    function gameLoop() {
      update();
      draw();
      if (gameRunning) {
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    // Controles
    let isDragging = false;
    function handleMove(clientX) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      paddle.x = x - paddle.width / 2;
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvasWidth) paddle.x = canvasWidth - paddle.width;
    }

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      launchBall();
      e.preventDefault();
    });
    canvas.addEventListener('touchmove', (e) => {
      if (isDragging) {
        handleMove(e.touches[0].clientX);
        e.preventDefault();
      }
    });
    canvas.addEventListener('touchend', () => isDragging = false);

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      launchBall();
    });
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) handleMove(e.clientX);
    });
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    // Botones
    homeBtn.addEventListener('click', () => window.location.href = 'index.html');
    pauseBtn.addEventListener('click', () => {
      gamePaused = true;
      showOverlay('PAUSA');
    });
    resumeBtn.addEventListener('click', () => {
      gamePaused = false;
      overlay.style.display = 'none';
    });
    menuBtn.addEventListener('click', () => window.location.href = 'index.html');

    document.getElementById('overlay').querySelectorAll('button')[0].addEventListener('click', () => {
      initGame();
    });

    // Iniciar
    window.addEventListener('load', initGame);
    window.addEventListener('resize', () => {
      if (gameRunning) initGame();
    });
  </script>
</body>
</html>
