<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0" />
  <meta name="google" content="notranslate">
  <meta name="robots" content="noindex, nofollow">
  <title>Brick Breaker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 8px;
      overflow: hidden;
      touch-action: none;
      width: 100%;
      max-width: 100vw;
    }
    .no-select {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    h1 {
      font-size: 1.6em;
      margin: 6px 0 4px;
      text-align: center;
      text-shadow: 0 0 6px #0f0;
    }
    #score {
      font-size: 1.1em;
      margin: 3px 0;
    }
    canvas {
      border: 2px solid #0a0;
      background: #000;
      display: block;
      margin: 6px auto;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
      max-width: 95vw;
      max-height: 70vh;
      width: auto;
      height: auto;
    }
    #home-btn, #pause-btn {
      position: absolute;
      top: 10px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid #0a0;
      background: rgba(20, 20, 20, 0.7);
      color: #0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      z-index: 5;
      cursor: pointer;
    }
    #home-btn { right: 10px; }
    #pause-btn { right: 52px; }
    #home-btn:active, #pause-btn:active {
      background: rgba(0, 255, 0, 0.2);
    }
    #game-over, #level-complete {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      color: #f00;
      font-size: 1.6em;
      text-shadow: 0 0 10px #f00;
      z-index: 10;
    }
    #level-complete {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    #game-over button, #level-complete button {
      margin-top: 20px;
      padding: 8px 20px;
      background: #111;
      color: #0f0;
      border: 1px solid #0a0;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 1.2em;
      cursor: pointer;
      margin: 10px;
    }
    #game-over button:active, #level-complete button:active {
      background: #030;
    }
  </style>
</head>
<body>
  <h1 class="no-select">Brick Breaker</h1>
  <div id="score" class="no-select">Puntos: 0</div>
  <canvas id="game"></canvas>

  <button id="home-btn" class="no-select">üè†</button>
  <button id="pause-btn" class="no-select">‚èØ</button>

  <div id="game-over">
    ¬°JUEGO TERMINADO!
    <button id="restart-btn">JUGAR DE NUEVO</button>
    <button id="menu-btn">VOLVER AL INICIO</button>
  </div>

  <div id="level-complete">
    ¬°NIVEL COMPLETADO!
    <button id="restart-btn-complete">JUGAR DE NUEVO</button>
    <button id="menu-btn-complete">VOLVER AL INICIO</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const gameOverScreen = document.getElementById('game-over');
    const levelCompleteScreen = document.getElementById('level-complete');
    const restartBtn = document.getElementById('restart-btn');
    const restartBtnComplete = document.getElementById('restart-btn-complete');
    const homeBtn = document.getElementById('home-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const menuBtn = document.getElementById('menu-btn');
    const menuBtnComplete = document.getElementById('menu-btn-complete');

    let canvasWidth, canvasHeight;
    let paddle = { x: 0, y: 0, width: 90, height: 14 };
    let ball = { x: 0, y: 0, radius: 6, dx: 4, dy: -4 };
    let bricks = [];
    const brickRows = 10;
    const brickCols = 12;
    const brickSize = 30;
    const brickPadding = 3;
    const brickOffsetTop = 40;

    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let gamePaused = false;
    let ballLaunched = false;
    let animationId = null;

    const brickColors = [
      '#0f0', '#0ff', '#ff0', '#f0f', '#f00',
      '#fa0', '#0af', '#f5f', '#afa', '#a0f'
    ];

    function drawPixelHeart(x, y, size = 8, color = '#f00') {
      const pixels = [
        [1,0,1,1,0,1],
        [1,1,1,1,1,1],
        [0,1,1,1,1,0],
        [0,0,1,1,0,0],
        [0,0,0,0,0,0]
      ];
      const pxSize = size / 6;
      ctx.fillStyle = color;
      for (let row = 0; row < pixels.length; row++) {
        for (let col = 0; col < pixels[row].length; col++) {
          if (pixels[row][col]) {
            ctx.fillRect(x + col * pxSize, y + row * pxSize, pxSize, pxSize);
          }
        }
      }
    }

    function drawLives() {
      const startX = 10;
      const startY = canvasHeight - 20;
      for (let i = 0; i < lives; i++) {
        drawPixelHeart(startX + i * 12, startY, 10);
      }
    }

    function initGame() {
      const maxWidth = window.innerWidth * 0.95;
      const maxHeight = window.innerHeight * 0.7;
      canvas.width = maxWidth;
      canvas.height = maxHeight;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;

      paddle.x = (canvasWidth - paddle.width) / 2;
      paddle.y = canvasHeight - 30;
      ball.x = canvasWidth / 2;
      ball.y = paddle.y - ball.radius - 5;
      ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
      ball.dy = -4;

      // === Centrar los ladrillos ===
      const totalBrickWidth = brickCols * brickSize + (brickCols - 1) * brickPadding;
      const brickOffsetLeft = (canvasWidth - totalBrickWidth) / 2;

      bricks = [];
      for (let r = 0; r < brickRows; r++) {
        bricks[r] = [];
        for (let c = 0; c < brickCols; c++) {
          const brickX = c * (brickSize + brickPadding) + brickOffsetLeft;
          const brickY = r * (brickSize + brickPadding) + brickOffsetTop;
          bricks[r][c] = { x: brickX, y: brickY, status: 1 };
        }
      }

      score = 0;
      lives = 3;
      gameRunning = true;
      gamePaused = false;
      ballLaunched = false;
      scoreDisplay.textContent = `Puntos: ${score}`;
      gameOverScreen.style.display = 'none';
      levelCompleteScreen.style.display = 'none';
      if (animationId) cancelAnimationFrame(animationId);
      gameLoop();
    }

    function drawPaddle() {
      ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            ctx.fillStyle = brickColors[r % brickColors.length];
            ctx.fillRect(brick.x, brick.y, brickSize, brickSize);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(brick.x, brick.y, brickSize, brickSize);
          }
        }
      }
    }

    function collisionDetection() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          const brick = bricks[r][c];
          if (brick && brick.status === 1) {
            if (
              ball.x + ball.radius > brick.x &&
              ball.x - ball.radius < brick.x + brickSize &&
              ball.y + ball.radius > brick.y &&
              ball.y - ball.radius < brick.y + brickSize
            ) {
              ball.dy = -ball.dy;
              brick.status = 0;
              score += 10;
              scoreDisplay.textContent = `Puntos: ${score}`;
              checkWin();
              return;
            }
          }
        }
      }
    }

    function checkWin() {
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          if (bricks[r][c] && bricks[r][c].status === 1) return;
        }
      }
      levelComplete();
    }

    function levelComplete() {
      gameRunning = false;
      levelCompleteScreen.style.display = 'flex';
    }

    function gameOver() {
      gameRunning = false;
      gameOverScreen.style.display = 'flex';
    }

    function launchBall() {
      if (!ballLaunched && gameRunning && !gamePaused) {
        ballLaunched = true;
      }
    }

    function update() {
      if (!gameRunning || gamePaused) return;

      if (ballLaunched) {
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvasWidth || ball.x - ball.radius < 0) {
          ball.dx = -ball.dx;
        }
        if (ball.y - ball.radius < 0) {
          ball.dy = -ball.dy;
        }
        if (
          ball.y + ball.radius > paddle.y &&
          ball.x > paddle.x &&
          ball.x < paddle.x + paddle.width &&
          ball.dy > 0
        ) {
          const hit = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          const angle = hit * (Math.PI / 3);
          const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
          ball.dx = speed * Math.sin(angle);
          ball.dy = -speed * Math.cos(angle);
        }
        if (ball.y + ball.radius > canvasHeight) {
          lives--;
          if (lives <= 0) {
            gameOver();
          } else {
            ballLaunched = false;
            ball.x = canvasWidth / 2;
            ball.y = paddle.y - ball.radius - 5;
            ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = -4;
          }
        }
        collisionDetection();
      } else {
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddle.y - ball.radius - 5;
      }
    }

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      drawBricks();
      drawPaddle();
      drawBall();
      drawLives(); // Corazones pixelados
    }

    function gameLoop() {
      update();
      draw();
      if (gameRunning) {
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    // Controles
    let isDragging = false;
    function handleMove(clientX) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      paddle.x = x - paddle.width / 2;
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvasWidth) paddle.x = canvasWidth - paddle.width;
    }

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      launchBall();
      e.preventDefault();
    });
    canvas.addEventListener('touchmove', (e) => {
      if (isDragging) {
        handleMove(e.touches[0].clientX);
        e.preventDefault();
      }
    });
    canvas.addEventListener('touchend', () => isDragging = false);

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      launchBall();
    });
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) handleMove(e.clientX);
    });
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    // Botones
    homeBtn.addEventListener('click', () => window.location.href = 'index.html');
    pauseBtn.addEventListener('click', () => {
      gamePaused = !gamePaused;
      pauseBtn.textContent = gamePaused ? '‚ñ∂' : '‚è∏';
    });
    restartBtn.addEventListener('click', initGame);
    restartBtnComplete.addEventListener('click', initGame);
    menuBtn.addEventListener('click', () => window.location.href = 'index.html');
    menuBtnComplete.addEventListener('click', () => window.location.href = 'index.html');

    window.addEventListener('load', initGame);
    window.addEventListener('resize', () => {
      if (gameRunning) initGame();
    });
  </script>
</body>
</html>